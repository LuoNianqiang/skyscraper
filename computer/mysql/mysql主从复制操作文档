

MySQL主从复制操作文档

 

1      主从复制工作原理



主从复制的原理：

分为同步复制和异步复制，实际复制架构中大部分为异步复制。


复制的基本过程如下： 

1) Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；

2) Master接收到来自Slave的IO进程的请求后，通过负责复制的IO进程根据请求信息读取制定日志指定位置之后的日志信息，返回给Slave 的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置；  

3) Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”；  

4) Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。

2      环境描述

操作系统：Red Hat Enterprise Linux Server release 6.5 (Santiago)

主服务器master：185.176.31.11

从服务器slave：185.176.31.12

数据库：MySQL 5.6.22

3      操作步骤

3.1      主从安装mysql

我们装的是mysql-5.6.22.tar.gz， 安装方法参照《MySQL安装规范文档V1.0-20170306.docx》

3.2      修改master、slave配置文件

master服务器配置：

[root]# vi /usr/local/mysql/etc/my.cnf

[mysqld]

server-id=202  #设置服务器唯一的id，默认是1，我们设置ip最后一段，slave设置203

log-bin=mysql-bin # 启用二进制日志

#binlog-ignore-db = mysql,information_schema  #忽略写入binlog的库

 

slave服务器配置：

[root]# vi /usr/local/mysql/etc/my.cnf

[mysqld]

server-id=203

replicate-do-db = abc     #只同步abc库

slave-skip-errors = all   #忽略因复制出现的所有错误

3.3        
重启主从服务器mysql

[root]# /etc/init.d/mysqld restart

3.4      在主服务器上建立帐户并授权slave

mysql>  msyql –u root –pcc08CC08 –S /data/mysqldata/mysql.sock

mysql> 
grant replication slave on *.* to 'sync'@'185.176.31.12' identified by
'cc08CC08'; #replication:复制

3.5      查看主数据库状态

mysql> show master status;

+------------------+----------+--------------+------------------+-------------------+

| File             | Position | Binlog_Do_DB |
Binlog_Ignore_DB | Executed_Gtid_Set |

+------------------+----------+--------------+------------------+-------------------+

| mysql-bin.000001 |      762 |              |                  |                   |

+------------------+----------+--------------+------------------+-------------------+

1 row in set (0.00 sec)

3.6      配置从数据库

mysql> change master to

-> master_host='185.176.31.11',

-> master_user='sync',

-> master_password='cc08CC08',

-> master_log_file='mysql-bin.000001',

-> master_log_pos=762;    

#Log和pos是master上随机获取的。这段也可以写到my.cnf里面。

3.7      启动slave同步进程并查看状态

mysql> start slave;

mysql> show slave status\G;

*************************** 1. row
***************************

               Slave_IO_State: Waiting for
master to send event

                  Master_Host: 185.176.31.11

                  Master_User: sync

                  Master_Port: 3306

                Connect_Retry: 60

              Master_Log_File: mysql-bin.000001

         
Read_Master_Log_Pos: 762

               Relay_Log_File: uwin-inav002-relay-bin.000002

                Relay_Log_Pos: 715

       
Relay_Master_Log_File: mysql-bin.000001

            
Slave_IO_Running:
Yes

            Slave_SQL_Running:
Yes

              Replicate_Do_DB: abc

         
Replicate_Ignore_DB:

          
Replicate_Do_Table:

      
Replicate_Ignore_Table:

     
Replicate_Wild_Do_Table:

 
Replicate_Wild_Ignore_Table:

                   Last_Errno: 0

                   Last_Error:

                 Skip_Counter: 0

         
Exec_Master_Log_Pos: 762

              Relay_Log_Space: 895

              Until_Condition: None

               Until_Log_File:

                Until_Log_Pos: 0

          
Master_SSL_Allowed: No

          
Master_SSL_CA_File:

          
Master_SSL_CA_Path:

              Master_SSL_Cert:

           
Master_SSL_Cipher:

               Master_SSL_Key:

       
Seconds_Behind_Master: 0

Master_SSL_Verify_Server_Cert: No

                Last_IO_Errno: 0

                Last_IO_Error:

               Last_SQL_Errno: 0

               Last_SQL_Error:

 
Replicate_Ignore_Server_Ids:

            
Master_Server_Id: 202

                  Master_UUID:
84bb0aa8-1aa7-11e7-8600-286ee4d9cad1

            
Master_Info_File: /data/mysqldata/master.info

                    SQL_Delay: 0

         
SQL_Remaining_Delay: NULL

     
Slave_SQL_Running_State: Slave has read all relay log; waiting for the
slave I/O thread to update it

          
Master_Retry_Count: 86400

                  Master_Bind:

     
Last_IO_Error_Timestamp:

    
Last_SQL_Error_Timestamp:

               Master_SSL_Crl:

          
Master_SSL_Crlpath:

          
Retrieved_Gtid_Set:

           
Executed_Gtid_Set:

                Auto_Position: 0

1 row in set (0.00 sec)

ERROR:No query specified

其中Slave_IO_Running 与 Slave_SQL_Running 的值都必须为YES，才表明状态正常。

3.8      验证主从同步

mysql> create database abc;

mysql> show databases;

+--------------------+

| Database  
|

+--------------------+

| information_schema |

| abc   
|

| mysql   
|

| performance_schema |

| test   
|

+--------------------+

在slave启动报错：

“last_io_error:
got fatal error 1236 from master when reading data from binary log: ‘could not
find first log file name in binary log index file’”

解决：报错的原因主要是slave设置master的二进制文件名或pos值不对应！

先flush logs；清空日志，在查看下主数据库的状态 show master
status;看下日志文件名字和position值；

再在slave中，执行：change master to
master_log_file=‘二进制日志名’,master_log_pos=值;

最后启动同步进程：start
slave；

